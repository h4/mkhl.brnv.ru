---
id: 684
title: Первый подход к ES6
date: 2015-09-02T18:26:13+03:00
author: h4
layout: revision
guid: http://mkhl.brnv.ru/681-revision-v1/
permalink: /681-revision-v1/
---
Спецификация ECMAScript6 уже пару месяцев как перешла в статус [ратифицированного стандарта](http://www.ecma-international.org/publications/standards/Ecma-262.htm), а я так и не написал на нём ни строчки. Но вот подвернулся шанс.

Суть задачи проста — у сообщества «[Веб-стандарты](http://web-standards.ru/)» есть твиттер-аккаунт для текстовых трансляций с конференций, [@webstandards_up](https://twitter.com/webstandards_up), и есть репозиторий для логов этой трансляции. Но не было нормального инструмента для создания md-файлов. Я уже делал попытку написать такой инструмент, но он был не доделан и заброшен.

Нужно сделать три простые вещи — выбрать самый старый твит из дня трансляции, получить json с твитами и сохранить их в виде markdown-файла. Первый шаг всё-таки нужно делать руками, заодно формируем файл с мета-информацией — дата конференции, её название и место проведения, всё остальное делает робот.

Самая нудная часть — это работа с api twitter. Но тут мне несказанно повезло, потому что создатели [jsunderhood.ru](http://jsunderhood.ru) создали модули `get-tweets` и `twitter-tokens`, а также `tweet.md` для парсинга тела твита (к сожалению, он не умеет раскрывать картинки). Собственно большая часть движка нашего робота также позаимствована у jsunderhood.ru, поэтому просто расскажу, какие вещи в ES6 мне понравились, а какие — не очень.

## Общая поддержка языка

Мне было лень ставить последний `io.js` и разбираться, что уже можно использовать, а что нет, поэтому я просто сделал `npm install --save babel` и запускал скрипты через `babel-node`.

В WebShtorm/PHPShtorm уже давно есть поддержка синтаксиса ES6, так что с этим тоже не было проблем.

## Модульная система

Сама по себе конструкция `import` мне давно знакома из питона, но в этом маленьком проекте я не увидел реальной разницы между использованием импортов и `require()`. Хотя, общий стандарт — это, безусловно, хорошо.

Поддержка `import` в шторме пока что частичная. Если нужный модуль описан в файлах приложения — его можно автоимпортировать через Alt+Click, как это делается для python-модулей и require-зависимостей. Но если модуль находится в `node_modules` — IDE его почему-то не видит.

## var, let, const

В принципе, у меня уже давно не было проблем с областью видимости переменных, правило — «всегда объявляй все переменные в начале функции» и поддержка IDE прекрасно справляются. Однако мысль использовать `const` для вещей которые не должны меняться в ходе работы приложения мне нравится. Вот только получается что почти всё становится константой, в том числе и лямбда-функции.

Кроме того, я привык к «single var» в кодстайле и множество `const` меня как-то смущают. Но тут дело привычки. На «single const» я скорее всего никогда не соглашусь, стройность отступов ломается.

## Стрелочные функции

Мне нравится функциональный стиль написания кода. Все эти `map()`, `filter()`, `reduce()`. Но меня очень утомляло написание анонимных функций внутри этих методов и необходимость пробрасывать контекст. Тут стрелочные функции однозначно рулят.

Не очень нравится как выглядит присвоение лямбда-функции переменной/константе — `const extractImages = (tweet) => tweet.entities.media;` — два символа «равно», которые стоят почти рядом затрудняют восприятие кода.

## Template strings

Это та вещь, которой мне очень не хватало в JavaScript. Собирать строки конкатенацией — это какое-то издевательство, особенно когда ты знаешь, что есть нормальные варианты типа `"Hello, {name}".format(greeting)`. Теперь у нас наконец-то есть template strings (вот только я так и не нашёл изящного переводя для этого термина).

Однако очень хочется посмотреть в глаза тому человеку, который решил, что для литеральной формы записи стоит использовать символ `` ` `` — на клавиатуре он находится в самом неудобном месте. Идеальным для меня было бы наличие метода `format()` у объекта `String()`, но такой вариант был скорее всего отвергнут по причине совместимости со сторонними библиотеками (привет, `Symbol.iterator`!).

## Выводы

Код, который у меня получился, выглядит намного стройнее чем аналогичный код на ES5, меньше вложенность, более коротки строки. В целом, мне нравится.

Конечно, это был микроскопический проект и делать какие-либо выводы рано, но в своих «домашних» проектах я постараюсь целиком перейти на ES6. А может и на основной работе тоже получится, во всяком случае, ничто не мешает использовать его на сервере.

Код, который у меня получился, вы можете посмотреть в [репозитории проекта](https://github.com/web-standards-ru/web-standards-up/tree/engine).