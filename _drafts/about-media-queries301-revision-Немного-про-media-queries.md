---
id: 304
title: Немного про media queries
date: 2012-05-22T17:40:53+03:00
author: h4
layout: revision
guid: http://mkhl.brnv.ru/301-revision/
permalink: /301-revision/
---
Вы не поверите, но на одном из сайтов Политеха я решил внедрить модный (а через годик — обязательный к использованию) Responsible design. Пока что по минимум, просто с media queries. И сделал небольшие выводы.

К.О.: media queries — часть спецификации CSS3, позволяющая уточнить область действия css-селектора. Представляет собой блок с указанием параметров устройства вывода, такие как тип, ширина и высота окна браузера, разрешение, ориентация в пространстве.

Мне нужно было задать разные значения блоков разметки для группы разрешений — менее 480px, от 480 до 800, от 800 до 1024, от 1024 до 1280 и более 1280.

Вывод первый — блоки media queries нужно располагать в порядке от меньшего к большему. Это позволит не извращаться в условиях, а также это просто «интуитивно понятно».

Для нижней границы я использовал уточнение по верхней границе, а дальше плясал от нижней:

<pre>@media screen and (max-width:480px) {
    /* Селекторы */
}
@media screen and (min-width:480px) {
    /* Селекторы */
}
@media screen and (min-width:800px) {


<pre>    /* Селекторы */
}</pre>


<p>
  Почему именно min-width? Браузер высчитывает реальное значение min-width исходя из размеров окна браузера, а max-width — от разрешения экрана, соответственно при разрешении 1920px сработают max-width(480px), max-width(800px) и так далее, вплоть до max-width(1920px).
</p>


<p>
  Если же использовать только min-width, то для ширины менее 480 пикселов вообще не будут применяться никакие селекторы. А это совсем не то, что нам нужно.
</p>


<p>
  Можем представить это правило графически:
</p>


<p>
  <a href="http://mkhl.brnv.ru/wp-content/uploads/2012/05/20120522-media-queries.png"><img class="alignnone size-full wp-image-302" title="20120522-media-queries" src="http://mkhl.brnv.ru/wp-content/uploads/2012/05/20120522-media-queries.png" alt="" width="575" height="148" srcset="https://mkhl.brnv.ru/wp-content/uploads/2012/05/20120522-media-queries.png 575w, https://mkhl.brnv.ru/wp-content/uploads/2012/05/20120522-media-queries-300x77.png 300w" sizes="(max-width: 575px) 100vw, 575px" /></a>
</p>


<h2>
  Специфичность media-queries
</h2>


<p>
  По всей видимости, media queries, как и прочие @-блоки не добавляют никакой специфичности селекторам, расположенным внутри блока. Поэтому любые свойства, которые должны зависеть от устройства вывода, должны располагаться только внутри media queries.
</p>


<p>
  Например, если мы хотим, чтобы блок <code>header</code> на разного рода смартфонах был высотой 30 пикселов, а в остальных случаях — 100 пикселов, то такой номер не прокатит:
</p>


<pre>@media screen and (max-width:480px) {
    header {
        height: 30px;
    }
}
header {
    height: 100px;
}</pre>


<p>
  При любых условиях блок <code>header</code> будет высотой 100 пикселов. Почему так происходит — нам покажет инспектор:<a href="http://mkhl.brnv.ru/wp-content/uploads/2012/05/by-default-2012-05-22-в-16.54.35.png"><img class="alignnone size-full wp-image-303" title="by default 2012-05-22 в 16.54.35" src="http://mkhl.brnv.ru/wp-content/uploads/2012/05/by-default-2012-05-22-в-16.54.35.png" alt="" width="267" height="223" /></a>
</p>


<p>
  Правила внутри @media применяются, но браузер встречает далее в таблице стилей ещё одно правило для header и применяет именно его. Поэтому изменим наш фрагмент кода:
</p>


<pre>@media screen and (max-width:480px) {
    header {
        height: 30px;
    }
}
@media screen and (max-width:480px) {
    header {
        height: 100px;
    }
}</pre>


<p>
  Теперь мы можем выстроить более точное правило, по которому нужно сортировать блоки @media: свойства с max-width записываются от больших значений к меньшим, а блоки с min-widht — наоборот, от меньшего к большему.
</p>


<p>
  С точки зрения скорости рендеринга (а вдруг вы — фанат БЭМ?) нужно всеми способами избегать переопределения свойств. Что же, изменим наш код ещё раз:
</p>


<pre>@media screen and (max-width:480px) {
    /* Селекторы */
}
@media screen and (min-width:480px) and (max-width:800px) {
    /* Селекторы */
}
@media screen and (min-width:800px) {
    /* Селекторы */
}</pre>


<p>
  Теперь для каждого диапазона ширины экрана будет применяться только один блок стилевых правил.
</p>


<h2>
  Подключение media queries
</h2>


<p>
  Писать большую «портянку» css с media-queries утомительно, а уж искать в ней нужное место — и того хуже. Что мы можем сделать?
</p>


<p>
  Все хорошие мальчики давно познали правила css-менеджмента и подключают файлы при помощи @import. Что можно и чего нельзя делать с media queries?
</p>


<p>
  Создадим три файла — media-small.css, media-normal.css и media-large.css, а потом попробуем подключить их.
</p>


<p>
  Сначала — как делать нельзя. Нельзая вот так:
</p>


<pre>@media screen and (max-width:480px) {
    @import url(media-small.css);
}
@media screen and (min-width:480px) and (max-width:800px) {
    @import url(media-normal.css);
}
@media screen and (min-width:800px) {
    @import url(media-large.css);
}</pre>


<p>
  В спецификации чёрным по белому сказано, что директивы @import должны идти в самом начале css-файла, и браузер подгружает импортируемые файлы последовательно в момент первой загрузки страницы. Никто не может заставить браузер  загружать файлы при изменении ширины браузера. Да и никто не захочет ждать, пока эта внешняя таблица загрузится.
</p>


<p>
  Мы можем пойти двумя правильными путями — указать медиа-выражения в подключаемых файлах и просто импортировать их, или же указать условия применимости в самой директиве @import. 
</p>


<p>
  Первый вариант:
</p>


<pre>@import url(media-small.css);
@import url(media-normal.css);
@import url(media-large.css);</pre>


<p>
  Второй вариант:
</p>


<pre>@import url(media-small.css) ;
@import url(media-normal.css);
@import url(media-large.css);</pre>