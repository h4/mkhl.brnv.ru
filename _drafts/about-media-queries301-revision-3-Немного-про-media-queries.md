---
id: 306
title: Немного про media queries
date: 2012-05-22T17:49:45+03:00
author: h4
layout: revision
guid: http://mkhl.brnv.ru/301-revision-3/
permalink: /301-revision-3/
---
Вы не поверите, но на одном из сайтов Политеха я решил внедрить модный (а через годик — обязательный к использованию) _Responsive design_. Пока что по минимум, просто с media queries. И сделал небольшие выводы.

К.О.: _media queries_ — часть спецификации _CSS3_, позволяющая уточнить область действия css-селектора. Представляет собой блок с указанием параметров устройства вывода, такие как тип, ширина и высота окна браузера, разрешение, ориентация в пространстве.

Мне нужно было задать разные значения блоков разметки для группы разрешений — менее 480px, от 480 до 800, от 800 до 1024, от 1024 до 1280 и более 1280.

Очевидно, что блоки media queries нужно располагать в порядке от меньшего разрешенияы к большему. Это позволит не извращаться в условиях, да и «интуитивно понятно».

Для нижней границы я использовал уточнение по верхней границе, а дальше плясал от нижней:

<pre>@media screen and (max-width:480px) {
    /* Селекторы */
}
@media screen and (min-width:480px) {
    /* Селекторы */
}
@media screen and (min-width:800px) {</pre>

<pre>    /* Селекторы */
}</pre>

Почему именно так? Браузер высчитывает реальное значение min-width исходя из размеров окна браузера, а max-width — от разрешения экрана, соответственно при разрешении 1920px сработают max-width(480px), max-width(800px) и так далее, вплоть до max-width(1920px).

Если же использовать только min-width, то для ширины менее 480 пикселов вообще не будут применяться никакие селекторы. А это совсем не то, что нам нужно.

Можем представить это правило графически:

[<img class="alignnone size-full wp-image-302" title="20120522-media-queries" src="http://mkhl.brnv.ru/wp-content/uploads/2012/05/20120522-media-queries.png" alt="" width="575" height="148" srcset="https://mkhl.brnv.ru/wp-content/uploads/2012/05/20120522-media-queries.png 575w, https://mkhl.brnv.ru/wp-content/uploads/2012/05/20120522-media-queries-300x77.png 300w" sizes="(max-width: 575px) 100vw, 575px" />](http://mkhl.brnv.ru/wp-content/uploads/2012/05/20120522-media-queries.png)

## Специфичность media-queries

По всей видимости, media queries, как и прочие @-блоки не добавляют никакой специфичности селекторам, расположенным внутри блока. Поэтому любые свойства, которые должны зависеть от устройства вывода, должны располагаться только внутри media queries.

Например, если мы хотим, чтобы блок `header` на разного рода смартфонах был высотой 30 пикселов, а в остальных случаях — 100 пикселов, то такой номер не прокатит:

<pre>@media screen and (max-width:480px) {
    header {
        height: 30px;
    }
}
header {
    height: 100px;
}</pre>

При любых условиях блок `header` будет высотой 100 пикселов. Почему так происходит — нам покажет инспектор:

[<img class="alignnone size-full wp-image-303" title="by default 2012-05-22 в 16.54.35" src="http://mkhl.brnv.ru/wp-content/uploads/2012/05/by-default-2012-05-22-в-16.54.35.png" alt="" width="267" height="223" />](http://mkhl.brnv.ru/wp-content/uploads/2012/05/by-default-2012-05-22-в-16.54.35.png)

Правила внутри @media применяются, но браузер встречает далее в таблице стилей ещё одно правило для header и применяет именно его. Поэтому изменим наш фрагмент кода:

<pre>@media screen and (max-width:480px) {
    header {
        height: 30px;
    }
}
@media screen and (max-width:480px) {
    header {
        height: 100px;
    }
}</pre>

Теперь мы можем выстроить более точное правило, по которому нужно сортировать блоки @media: свойства с _max-width_ записываются _от больших значений к меньшим_, а блоки с _min-widht_ — наоборот, _от меньшего к большему_.

А ведь с точки зрения скорости рендеринга (а вдруг вы — фанат _БЭМ_?) нужно всеми способами избегать переопределения свойств. Что же, изменим наш код ещё раз:

<pre>@media screen and (max-width:480px) {
    /* Селекторы */
}
@media screen and (min-width:480px) and (max-width:800px) {
    /* Селекторы */
}
@media screen and (min-width:800px) {
    /* Селекторы */
}</pre>

Теперь для каждого диапазона ширины экрана будет применяться только один блок стилевых правил. Проверьте сами в испекторе — я не вру!

## Подключение media queries

Писать большую «портянку» css с media-queries утомительно, а уж искать в ней нужное место через пару недель — и того хуже. Что мы можем сделать?

Все хорошие мальчики давно познали правила css-менеджмента и подключают файлы при помощи _@import_. Что можно и чего нельзя делать с media queries?

Создадим три файла — _media-small.css_, _media-normal.css_ и _media-large.css_, а потом попробуем подключить их.

Сначала — как делать нельзя. Нельзая вот так:

<pre>@media screen and (max-width:480px) {
    @import url(media-small.css);
}
@media screen and (min-width:480px) and (max-width:800px) {
    @import url(media-normal.css);
}
@media screen and (min-width:800px) {
    @import url(media-large.css);
}</pre>

В спецификации чёрным по белому сказано, что директивы @import должны идти в самом начале css-файла, и браузер подгружает импортируемые файлы последовательно в момент первой загрузки страницы. Никто не может заставить браузер загружать файлы при изменении ширины браузера. Да и никто не захочет ждать, пока эта внешняя таблица загрузится.

Мы можем пойти двумя правильными путями — указать медиа-выражения в подключаемых файлах и просто импортировать их, или же указать условия применимости в самой директиве @import.

Первый вариант:

<pre>@import url(media-small.css);
@import url(media-normal.css);
@import url(media-large.css);</pre>

Второй вариант:

<pre>@import url(media-small.css) screen and (max-width:480px);
@import url(media-normal.css) screen and (min-width:480px) and (max-width:800px);
@import url(media-large.css) screen and (min-width:800px);</pre>

Я считаю, что разумнее пользоваться первым вариантом, поскольку рано или поздно придётся делать объединение всех таблиц стилей для выкладки на production. И вот в этом случае, при использовании первого способа будет гораздо проще автоматизировать процесс сборки финального файла стилей и протести.

Responsive design всем, посоны!